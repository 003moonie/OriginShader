//不应修改的数学常量，物理常量等
#define AUTHOR		linlin
#define MATH_PI		3.141592653589793
#define MATH_E		2.718281828459045
#define MATH_PHI	1.618033988749895
#define MATH_Y		0.577215664901533
#define GAMMA		2.2
#define F0			0.04
#define GRAY		0.18
#define RGB			vec3(0.7000, 0.5461, 0.4358)

#include "Users/Set.txt"



//test



//math
float pow3_2(float x)
{
//	return pow(x, 3.0/2.0);
	return x * sqrt(x);
}

float pow2(float x)
{
	return x * x;
}

float pow3(float x)
{
	return x * x * x;
}

float pow4(float x)
{
	float x2 = x * x;
	return x2 * x2;
}

float pow5(float x)
{
	float x2 = x * x;
	return x2 * x2 * x;
}

bool equ3(vec3 v)
{
#if FAST_MATH
//	return v.x == v.y && v.y == v.z;
	return all(v.xy - v.yz);
#else
//	return abs(v.x-v.y) < 0.000002 && abs(v.y-v.z) < 0.000002;
	return all(lessThan(abs(v.xy - v.yz), vec2(0.000002)));
#endif
}

float saturate(float x)
{
	return clamp(x,0.0,1.0);
}

mat3 inverse_mat3(mat3 m)
{
	float Determinant = 
		  m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
		- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
		+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
	
	mat3 Inverse;
	Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
	Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
	Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
	Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
	Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
	Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
	Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
	Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
	Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
	Inverse /= Determinant;
	
	return Inverse;
}

mat4 inverse_mat4(mat4 m)
{
	float Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
	float Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
	float Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
	
	float Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
	float Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
	float Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
	
	float Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
	float Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
	float Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
	
	float Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
	float Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
	float Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
	
	float Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
	float Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
	float Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
	
	float Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
	float Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
	float Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
	
	const vec4 SignA = vec4( 1.0, -1.0,  1.0, -1.0);
	const vec4 SignB = vec4(-1.0,  1.0, -1.0,  1.0);
	
	vec4 Fac0 = vec4(Coef00, Coef00, Coef02, Coef03);
	vec4 Fac1 = vec4(Coef04, Coef04, Coef06, Coef07);
	vec4 Fac2 = vec4(Coef08, Coef08, Coef10, Coef11);
	vec4 Fac3 = vec4(Coef12, Coef12, Coef14, Coef15);
	vec4 Fac4 = vec4(Coef16, Coef16, Coef18, Coef19);
	vec4 Fac5 = vec4(Coef20, Coef20, Coef22, Coef23);
	
	vec4 Vec0 = vec4(m[1][0], m[0][0], m[0][0], m[0][0]);
	vec4 Vec1 = vec4(m[1][1], m[0][1], m[0][1], m[0][1]);
	vec4 Vec2 = vec4(m[1][2], m[0][2], m[0][2], m[0][2]);
	vec4 Vec3 = vec4(m[1][3], m[0][3], m[0][3], m[0][3]);
	
	vec4 Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
	vec4 Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
	vec4 Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
	vec4 Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);
	
	mat4 Inverse = mat4(Inv0, Inv1, Inv2, Inv3);
	
	vec4 Row0 = vec4(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);
	
	float Determinant = dot(m[0], Row0);
	
	Inverse /= Determinant;
	
	return Inverse;
}





//geometry
float veccos(vec3 v1, vec3 v2)
{
//	return dot(v1, v2) / (length(v1) * length(v2));
	return dot(v1, v2) * inversesqrt(dot(v1,v1) * dot(v2,v2));
}

//球心在原点
float intraybal(float r, vec3 p, vec3 d)
{
	float r2 = r * r;
	float l = dot(d, -p);
	float p2 = dot(p, p);
	float t = l * l + r2;
	float q = sqrt(t - p2);
//可以提前判定无交点的情况，但动态分支反而会造成开销故不使用提前判定
	return ((p2 > r2 && l < 0.0) || t < p2) ? -1.0 : sign(r2 - p2) * q + l;
}

//球心在原点且只求解距离
float lenraybal(float r, vec3 p, vec3 d)
{
	float r2 = r * r;
	float l = dot(d, -p);
	float p2 = dot(p, p);
	float t = l * l + r2;
	float q = sqrt(t - p2);
	return sign(r2 - p2) * q + l;
}

//球心在原点且只进行相交测试
bool nohitraybal(float r, vec3 p, vec3 d)
{
	float r2 = r * r;
	float l = dot(d, -p);
	float p2 = dot(p, p);
	float t = l * l + r2;
	return ((p2 > r2 && l < 0.0) || t < p2);
}





//tonemap
vec3 F(vec3 x)
{
	const float A = 0.22;
	const float B = 0.30;
	const float C = 0.10;
	const float D = 0.20;
	const float E = 0.01;
	const float F = 0.30;
	return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

vec3 FilmicToneMapping(vec3 color, float adapted_lum)
{
//http://filmicgames.com/archives/75
	const vec3 WHITE = vec3(11.2);
	return F(1.6 * adapted_lum * color) / F(WHITE);
}

vec3 ACESToneMapping(vec3 color, float adapted_lum)
{
//https://www.oscars.org/science-technology/sci-tech-projects/aces
	const float A = 2.51;
	const float B = 0.03;
	const float C = 2.43;
	const float D = 0.59;
	const float E = 0.14;
	color *= adapted_lum;
	return (color * (A * color + B)) / (color * (C * color + D) + E);
}

vec3 tonemap(vec3 c, float l)
{
#if TONEMAP == 1
	return ACESToneMapping(c, l);
#elif TONEMAP == 2
	return FilmicToneMapping(c, l);
#else
	return c * vec3(l);
#endif
}





//random, hash, noise

float ThresholdMap16(vec2 p)
{
//https://en.wikipedia.org/wiki/Ordered_dithering
	const mat4 TM = mat4(
			0.0000,0.5000,0.1250,0.5250,
			0.7500,0.2500,0.8750,0.3750,
			0.1875,0.6875,0.0625,0.5625,
			0.9375,0.4375,0.8125,0.3125);
	p += vec2(2400.0,1080.0);
	uvec2 p4 = uvec2(mod(p, 4.0));
	uvec2 p16 = uvec2(mod(p, 16.0) * (1.0 / 4.0));
	return TM[p4.y][p4.x] + TM[p16.y][p16.x] * (1.0 / 16.0);
}

float hash21(vec2 p)
{
#if MOBILE	//fp16
	const float C = 1024.0 / MATH_PHI;
	vec4 v = (1.0 / 32.0) * p.xyxy + vec4(0.1, 0.2, 0.3, 0.4);
#else		//fp32
	const float C = 65536.0 / MATH_PHI;
	vec4 v = (1.0 / 65536.0) * p.xyxy + vec4(0.1, 0.2, 0.3, 0.4);
#endif

	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);

	return v.x;
}

vec2 hash22(vec2 p)
{
#if MOBILE	//fp16
	const float C = 1024.0 / MATH_PHI;
	vec4 v = (1.0 / 32.0) * p.xyxy + vec4(0.1, 0.2, 0.3, 0.4);
#else		//fp32
	const float C = 65536.0 / MATH_PHI;
	vec4 v = (1.0 / 65536.0) * p.xyxy + vec4(0.1, 0.2, 0.3, 0.4);
#endif

	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);
	v = fract(v.yzwx * C + v.xyzw);

	return v.xy;
}

float pernoi_2D(vec2 p)
{
	vec4 pi = vec4(floor(p), ceil(p));
	vec2 pf = fract(p);
	vec4 dp = vec4(0.0,0.0,1.0,1.0) - pf.xyxy;

	vec4 d = vec4 (
			dot(hash22(pi.zw)*2.0-1.0, dp.zw),
			dot(hash22(pi.xw)*2.0-1.0, dp.xw),
			dot(hash22(pi.xy)*2.0-1.0, dp.xy),
			dot(hash22(pi.zy)*2.0-1.0, dp.zy)	);

#if FAST_PERLIN
	vec2 a = (-2.0 * pf + 3.0) * pf * pf;
#else
	vec2 a = ((6.0 * pf - 15.0) * pf + 10.0) * pf * pf * pf;
#endif

	vec2 x = mix(d.yz, d.xw, a.x);
	return mix(x.y, x.x, a.y);
}

vec2 perpar_2D(vec2 p)
{
	vec4 pi = vec4(floor(p), ceil(p));
	vec2 pf = fract(p);
	vec4 dp = vec4(0.0,0.0,1.0,1.0) - pf.xyxy;

	vec4 d = vec4 (
			dot(hash22(pi.zw)*2.0-1.0, dp.zw),
			dot(hash22(pi.xw)*2.0-1.0, dp.xw),
			dot(hash22(pi.xy)*2.0-1.0, dp.xy),
			dot(hash22(pi.zy)*2.0-1.0, dp.zy)	);

#if FAST_PERLIN
	vec2 a = (-2.0 * pf + 3.0) * pf * pf;
	vec2 b = (-6.0 * pf + 6.0) * pf;
#else
	vec2 a = ((6.0 * pf - 15.0) * pf + 10.0) * pf * pf * pf;
	vec2 b = ((30.0 * pf - 60.0) * pf + 30.0) * pf * pf;
#endif

	return ((d.wy - d.zz) + (d.z + d.x - d.w - d.y) * a.yx) * b.xy;
}

float valnoi_2D(vec2 p)
{
	vec4 pi = vec4(floor(p), ceil(p));
	vec2 pf = fract(p);
	vec4 dp = vec4(0.0,0.0,1.0,1.0) - pf.xyxy;

	vec4 d = vec4 (
			hash21(pi.zw),
			hash21(pi.xw),
			hash21(pi.xy),
			hash21(pi.zy)	);
			
#if FAST_VALUE
	vec2 a = (-2.0 * pf + 3.0) * pf * pf;
#else
	vec2 a = ((6.0 * pf - 15.0) * pf + 10.0) * pf * pf * pf;
#endif

	vec2 x = mix(d.yz, d.xw, a.x);
	return mix(x.y, x.x, a.y);
}

vec2 valpar_2D(vec2 p)
{
	vec4 pi = vec4(floor(p), ceil(p));
	vec2 pf = fract(p);
	vec4 dp = vec4(0.0,0.0,1.0,1.0) - pf.xyxy;

	vec4 d = vec4 (
			hash21(pi.zw),
			hash21(pi.xw),
			hash21(pi.xy),
			hash21(pi.zy)	);

#if FAST_VALUE
	vec2 a = (-2.0 * pf + 3.0) * pf * pf;
	vec2 b = (-6.0 * pf + 6.0) * pf;
#else
	vec2 a = ((6.0 * pf - 15.0) * pf + 10.0) * pf * pf * pf;
	vec2 b = ((30.0 * pf - 60.0) * pf + 30.0) * pf * pf;
#endif

	return ((d.wy - d.zz) + (d.z + d.x - d.w - d.y) * a.yx) * b.xy;
}

float voro_2D(vec2 p)
{
	float m = 2.0;

#if FAST_VORO
	vec2 b = round(p);
	for(float i=-1.0;i<=0.0;i++)
		for(float j=-1.0;j<=0.0;j++)
#else
	vec2 b = floor(p);
	for(float i=-1.0;i<=1.0;i++)
		for(float j=-1.0;j<=1.0;j++)
#endif
		{
			vec2 c = b + vec2(i,j);
			vec2 h = c + hash22(c);
			m = min(distance(p,h),m);
		}

	return m;
}





//	vanilla shader

float fogtime(vec4 fogcol)
{
//	三次多项式拟合，四次多项式拟合曲线存在明显突出故不使用
	const vec4 k = vec4(349.305545, -159.858192, 30.557216, -1.628452);
	const float x0 = 1.0;
	float x1 = fogcol.g;
	float x2 = x1 * x1;
	float x3 = x2 * x1;
	return fogcol.g > 0.213101 ? 1.0 : dot(vec4(x3, x2, x1, x0), k);
}

float uv1time(float r1)
{
//	四次多项式拟合
	const vec4 k = vec4(39.581994, -74.236058, 33.842220, 9.368113);
	float r2 = r1 * r1;
	float r4 = r2 * r2;
	return dot(vec4(r4, r2 * r1, r2, r1), k) - 7.363836;
}

float curtime(vec4 curcol, vec4 fogcol)
{
//	原始数据线性变化，无需拟合即可解得精确值
	return 1.812780 * (curcol.b / fogcol.a) - 0.918842;
}

//对colormap建模在rgb空间内与color向量求交，精确计算并分离出方块暗角浓度
float getleaao(vec3 c)
{
	const vec3 O = vec3(0.682352941176471, 0.643137254901961, 0.164705882352941);
	const vec3 N = vec3(0.195996912842436, 0.978673548072766,-0.061508507207520);

	return length(c) / dot(O,N) * dot(normalize(c),N);
}

float getgraao(vec3 c)
{
	const vec3 O = vec3(0.745098039215686, 0.713725490196078, 0.329411764705882);
	const vec3 N = vec3(0.161675377098328, 0.970052262589970, 0.181272392504186);

	return length(c) / dot(O,N) * dot(normalize(c),N);
}

vec4 getvarcol(vec4 c)
{
	if(equ3(c.rgb))
	{
		c.a = c.r;
		c.rgb = vec3(1.0,1.0,1.0);
	}
	else
	{
		c.a = c.a<0.001 ? getleaao(c.rgb) : getgraao(c.rgb);
		c.rgb = c.rgb / c.a;
	}
	return c;
}

float getshadow(vec2 uv1, vec4 varcol)
{
	float shasky = (uv1.y - 0.875) / SOFTSHADOW;
//	float shablo = (varcol.a - 0.6) / SOFTSHADOW;
	float shadow = saturate(shasky + 1.0) * 2.0 - 1.0;
	return (sqrt(1.0 - shadow * shadow) * shadow + asin(shadow)) * (1.0 / MATH_PI) + 0.5;
}

float uv1x2lig(float uv1x)
{
	float l = max((14.0 / 16.0) - uv1x, 0.0) * 16.0 + 0.5;
	return 1.0 / (l * l) - (1.0 / pow2(14.5));
}

float uv1y2lig(float uv1y)
{
	float l = ((15.0 / 16.0) - uv1y) * 16.0 + (1.0 / 16.0);
	return atan(3.0 / l) * (2.0 / MATH_PI);
}





//atmosphere

vec2 airden(vec3 pos, const float r, const float hr, const float hm)
{
//	float h = max(length(pos) - r, 0.0);
	float h = length(pos) - r;
	return exp(h * (1.0 / vec2(-hr,-hm)));
}

void setprpm(out float pr, out float pm, float c, float g)
{
//Oskar Elek “Rendering Parametrizable Planetary Atmospheres with Multiple Scattering in Real-Time”
	pr = (1.0 / (4.0 * MATH_PI)) * (8.0 / 10.0) * (7.0 / 5.0 + 1.0 / 2.0 * c);
	pm = (1.0 / (4.0 * MATH_PI)) * (3.0 * (1.0 - g * g) * (1.0 + c * c)) / (2.0 * (2.0 + g * g) * pow3_2(1.0 + g * g - 2.0 * g * c));
}

vec2 atmads(vec3 sampos, vec3 sunvec, vec2 adm)
{
	vec2 adssum = vec2(0.0);
	vec2 ads0;
	vec2 ads1 = adm;

	vec3 maxpos = sampos + max(dot(-sampos,sunvec), 0.0) * sunvec;
	vec2 mp = airden(maxpos,EARTH_R,HR,HM);
	
	float em = mp.x - adm.x;
	//不能用1.0，否则会出现ln0
	float dp = (-2.0 * mp.x + adm.x) * (0.99999 / SAMNUM);
	
	for(float j=1.0; j<=SAMNUM; j++)
	{
		float p = -abs(em + dp * j) + mp.x;
		float r = log(p) * -HR + EARTH_R;
		float l = max(lenraybal(r, sampos, sunvec),0.0);
		sampos += l * sunvec;

		ads0 = ads1;
		ads1 = airden(sampos,EARTH_R,HR,HM);
		adssum += (ads0 + ads1) * l;
	}

	//梯形积分延迟常量计算
	return adssum * 0.5;

}

vec3 physicsky(vec3 skylig, vec3 marpos, vec3 stavec, vec3 orisunlig, vec3 sunvec, vec4 scrpos)
{
#if AUTO_MARCH_NUM
	float marnum = inversesqrt(abs(stavec.y) + 0.0001) * MARNUM;
	marnum = fract(marnum) > ThresholdMap16(scrpos.xy) ? ceil(marnum) : floor(marnum);
#else
	const float marnum = MARNUM;
#endif

	vec2 admsum = vec2(0.0);
	vec2 adm0;
	vec2 adm1 = airden(marpos, EARTH_R, HR, HM);

	vec3 marsumr = vec3(0.0);
	vec3 expodr0;
	vec3 expodr1 = vec3(0.0);

	vec3 marsumm = vec3(0.0);
	vec3 expodm0;
	vec3 expodm1 = vec3(0.0);

	if (nohitraybal(EARTH_R * 0.9996, marpos, sunvec))
	{
		//第零个采样点的步进距离为0，只需计算阳光方向的光程
		vec2 adorigin = atmads(marpos, sunvec, adm1);
		vec3 odorigin = (LR + O3) * adorigin.x + LM * adorigin.y;

		expodr1 = exp(-odorigin) * adm1.x;
		expodm1 = exp(-odorigin) * adm1.y;
	}

	float maxl = intraybal(EARTH_R * 0.9995, marpos, stavec);
	bool hitflag = maxl >= 0.0;

	vec3 maxpos = marpos + (hitflag ? maxl : max(dot(-marpos, stavec), 0.0)) * stavec;
	vec2 mp = airden(maxpos, EARTH_R, HR, HM);

	float em = mp.x - adm1.x;
	//不能用1.0，否则会出现ln0
	float dp = (hitflag ? (-em) : (-2.0 * mp.x + adm1.x)) * (0.99999 / marnum);

	for (float j = 1.0; j <= marnum; j++)
	{
		float p = -abs(em + dp * j) + mp.x;
		float r = log(p) * -HR + EARTH_R;
		float l = max(lenraybal(r, marpos, stavec), 0.0);

		marpos += l * stavec;

		adm0 = adm1;
		adm1 = airden(marpos, EARTH_R, HR, HM);
		admsum += (adm0 + adm1) * l;

		//如果直接用r会有奇怪的条纹
		if (nohitraybal(EARTH_R * 0.9994, marpos, sunvec))
		{
			vec2 adssum = atmads(marpos, sunvec, adm1);

			vec2 ad = adssum + admsum;
			vec3 od = (LR + O3) * ad.x + LM * ad.y;

			expodr0 = expodr1;
			expodr1 = exp(-od) * adm1.x;
			marsumr += (expodr0 + expodr1) * l;

			expodm0 = expodm1;
			expodm1 = exp(-od) * adm1.y;
			marsumm += (expodm0 + expodm1) * l;
		}
	}

	//梯形积分延迟常量计算
	admsum *= 0.5;
	marsumr *= 0.5;
	marsumm *= 0.5;

	float pr, pm;
	setprpm(pr, pm, dot(sunvec, stavec), G);

	vec3 insca = orisunlig * (pr * LR * marsumr + pm * LM * marsumm);
	vec3 outsca = hitflag ? vec3(0.0) : skylig * exp((-(LR + O3)) * admsum.x + (-LM) * admsum.y);

	return outsca + insca;
}

void setfog(out vec3 outsca, out vec3 insca, vec3 stapos, vec3 marpos, vec3 sunlig, vec3 sunvec, vec2 uv1)
{
	const float marnum = MARNUM;

	vec3 delpos = stapos - marpos;
	vec3 stavec = normalize(delpos);

	vec2 admsum = vec2(0.0);
	vec2 adm0;
	vec2 adm1 = airden(marpos,EARTH_R,HR,HM);

	vec3 marsumr = vec3(0.0);
	vec3 expodr0;
	vec3 expodr1 = vec3(0.0);
	
	vec3 marsumm = vec3(0.0);
	vec3 expodm0;
	vec3 expodm1 = vec3(0.0);

	if(nohitraybal(EARTH_R * 0.9996,marpos,sunvec))
	{
		//第零个采样点的步进距离为0，只需计算阳光方向的光程
		vec2 adorigin = atmads(marpos, sunvec, adm1);
		vec3 odorigin = (LR + O3) * adorigin.x + LM * adorigin.y;
		
		expodr1 = exp(-odorigin) * adm1.x;
		expodm1 = exp(-odorigin) * adm1.y;
	}

	float l = length(delpos) * (1.0 / marnum);

	for(float j=1.0; j<=marnum; j++)
	{
		marpos += l * stavec;
		
		adm0 = adm1;
		adm1 = airden(marpos,EARTH_R,HR,HM);
		admsum += (adm0 + adm1) * l;
		
		//如果直接用r会有奇怪的条纹
		if(nohitraybal(EARTH_R * 0.9994,marpos,sunvec))
		{
			vec2 adssum = atmads(marpos, sunvec, adm1);
			
			vec2 ad = adssum + admsum;
			vec3 od = (LR + O3) * ad.x + LM * ad.y;
			
			expodr0 = expodr1;
			expodr1 = exp(-od) * adm1.x;
			marsumr += (expodr0 + expodr1) * l;
			
			expodm0 = expodm1;
			expodm1 = exp(-od) * adm1.y;
			marsumm += (expodm0 + expodm1) * l;
		}
	}
	
	//梯形积分延迟常量计算
	admsum  *= 0.5;
	marsumr *= 0.5;
	marsumm *= 0.5;
	
	float pr, pm;
	setprpm(pr, pm, dot(sunvec, stavec), G);
	
	insca = uv1.y * (pr * LR * marsumr + pm * LM * marsumm);
	outsca = exp((-(LR + O3)) * admsum.x + (-LM) * admsum.y);
}

vec3 getsunlig(vec3 marpos, vec3 orisunlig, vec3 sunvec)
{
	if(nohitraybal(EARTH_R * 0.9999,marpos,sunvec))
	{
		vec2 adm = airden(marpos,EARTH_R,HR,HM);
		vec2 adorigin = atmads(marpos, sunvec, adm);
		return orisunlig * exp((-(LR + O3)) * adorigin.x + (-LM) * adorigin.y);
	}
	else
		return vec3(0.0);
}

vec3 physicsun(vec3 orisunlig, vec3 sunvec, vec3 skyvec, const float r)
{
	//http://www.physics.hmc.edu/faculty/esin/a101/limbdarkening.pdf
	const vec3 u = vec3(1.0 ,1.0 ,1.0);
	const vec3 a = vec3(0.397 ,0.503 ,0.652);
	/*const*/ float s = 2.0 * MATH_PI * (1.0 - cos(r));

	float theta = acos(dot(skyvec,sunvec));

	if(theta < r)
	{
	//	vec3 lig = orisunlig / s;
		vec3 lig = orisunlig;
		float mu = sqrt(1.0 - pow2(theta / r));
		vec3 factor = 1.0 + u * (pow(vec3(mu) , a) - 1.0);

		return lig * factor;
	}
	else
	{
		return vec3(0.0);
	}
}





//brdf bsdf

vec3 gamma2line(vec3 x)
{
	return pow(x, vec3(GAMMA));
}

vec3 line2gamma(vec3 x)
{
	return pow(x, vec3(1.0 / GAMMA));
}

vec3 lig2col(vec3 lig)
{
	return line2gamma(tonemap(lig, LUM));
}

vec3 Diffuse_Lambert(vec3 col)
{
	return (1.0 / MATH_PI) * col; 
}





//origin shader light system

vec3 skyrender(vec3 campos, vec3 skyvec, vec3 orisunlig, vec3 sunvec, vec4 scrpos)
{
	vec3 skylig = vec3(0.0);

	skylig += physicsun(orisunlig, sunvec, skyvec, SUN_R);
	skylig = physicsky(skylig, campos, skyvec, orisunlig, sunvec, scrpos);

	return min(skylig,1000.0);
}

void setsunlig(float t, vec3 campos, out vec3 orisunlig, out vec3 sunlig, out vec3 sunvec)
{
	const mat3 M = mat3(
		cos(SUNDEC), 0.0, sin(SUNDEC),
		0.0, 1.0, 0.0,
		-sin(SUNDEC), 0.0, cos(SUNDEC) );
	if(t > -0.02)
	{
		sunvec = vec3(cos(t),sin(t),0.0);
		orisunlig = gamma2line(SUNCOL) * SUNLIGHT_A;
	}
	else
	{
		sunvec = -vec3(cos(t),sin(t),0.0);
		orisunlig = gamma2line(MOOCOL) * MOOLIGHT_A;
	}
	sunvec = M * sunvec;
	sunlig = getsunlig(campos, orisunlig, sunvec);
}

vec3 getenvlig(vec2 uv1, vec3 sunlig, vec3 orisunlig, vec3 marpos, vec3 sunvec, float ao)
{
	vec3 skylum = (2.0 * MATH_PI) * physicsky(vec3(0.0), marpos, normalize(vec3(0.0,2.0,1.0)), orisunlig, sunvec, vec4(0.0));
	vec3 blolum = (sunlig + skylum) * GRAY * exp(-3.0 * (0.9375 - uv1.y));
	return mix(blolum, skylum, uv1y2lig(uv1.y) * 0.5) * ao;
}

vec3 getpoilig(vec2 uv1)
{
	vec3 POILIG = gamma2line(POICOL) * POILIGHT_A;
	return POILIG * uv1x2lig(uv1.x);
}

